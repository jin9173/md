---
title: 파이채우기 - 리스트,튜플,딕셔너리,셋
date: 2019-12-10 14:44:50
categories: 
    - Study
    - Python
---

#### 리스트와 튜플

: 파이썬은 두 가지 다른 시퀀스 타입의 데이터가 있는데 이는 **튜플(tuple)과 리스트(list)**이다. 이 구조에는 0 혹은 그 이상의 항목이 포함되어있고, 이들 항목은 다른 타입이 될 수 있다. 즉, 각 요소는 어떤 객체도 될 수 있다. <span style="color: red">튜플은 불변(immutable)하고, 리스트는 변경가능(mutable)하다.</span>

## 1. 리스트 (List) `[]`

: 데이터를 순차적으로 파악하는데 유용 (다른 타입의 요소도 포함 가능)

- 리스트 생성: `[]`, `list()`

- 형변환: `list(객체)`

- 인덱싱: `리스트객체[오프셋]`: 오프셋으로 하나의 특정 값을 추출/변경

- 슬라이싱: `리스트객체[start:end:step]`: 슬라이스로 항목 추출

- `리스트객체.append('추가할 리스트 요소')`: 리스트의 끝에 항목 추가

- 리스트 병합

  - `리스트객체1.extend(리스트객체2)`
  - `리스트객체1 += 리스트객체2`

- `리스트객체.insert(오프셋, '해당 오프셋에 추가할 리스트 요소')`: 지정한 오프셋 위치에 항목 추가

- `del 리스트객체['삭제할 항목의 오프셋']`: 오프셋으로 항목 삭제

- `리스트객체.remove('제거할 리스트 항목')`: 값으로 항목 삭제

- 오프셋으로 항목을 얻은 후 삭제

  - `리스트객체.pop()`: 맨 뒤 항목을 얻은 후 삭제
  - `리스트객체.pop(오프셋)`: 해당 오프셋에 있는 항목을 얻은 후 삭제

- `리스트객체.index('항목의 값')`: 값으로 항목 오프셋 찾기

- `'리스트항목' in 리스트객체`: 리스트에서 어떤 값의 존재를 확인 (리스트객체 안에 '리스트항목'이 있냐?) (Boolean값 반환, 문자열에서도 사용 가능)

- `리스트객체.count('개수를 셀 항목')`: 리스트에서 특정 값이 얼마나 있는지 셈

- 정렬하기

  - `리스트복사본 = sorted(리스트객체)`: 오름차순으로 정렬된 리스트의 복사본 반환 (원본 리스트는 변하지 않음)
  - `리스트객체.sort()`: 리스트객체를 오름차순으로 정렬하고 반환 (원본 리스트는 변함)
  - `리스트객체.sort(reverse=True)`: 내림차순으로 정렬

- `len(리스트객체)`: 리스트의 길이 반환 (항목 개수 얻기)

- `변수 = 리스트객체.copy()`: 변수에 리스트객체를 복사하여 할당

  ~~~python
  a = [1, 2, 3]
  b = a.copy() # 변수 b에 리스트객체 a를 복사하여 할당
  c = list(a) # 리스트로 변환
  d = a[:] # 리스트를 변환
  ~~~

~~~python
# 리스트로 형변환 split()
# split()으로 문자열을 구분자로 나누어서 리스트로 변환
birthday = '03/07/1991'
birthday_list = birthday.split('/')

print(birthday_list) # ['03', '07', '1991']
~~~

~~~python
# 문자열로 변환 join()
friends = ['Harry', 'Hermione', 'Ron']
separator = '*'
joined = separator.join(friends)

print(joined) # Harry*Hermione*Ron
print(type(joined)) # <class 'str'>

separated = joined.split(separator)

print(separated) # ['Harry', 'Hermione', 'Ron']
print(type(separated)) # <class 'list'>
~~~

<br>

## 2. 튜플 (Tuple) `()`

- 임의적인 항목의 시퀀스
- 튜플은 불변 (튜플을 정의한 후에는 추가, 삭제, 수정을 할 수 없다) → 리스트의 상수 버전

<br>

- 튜플 생성: `()`
- 튜플 언팩킹: 한번에 여러 변수에 할당 `변수1, 변수2, 변수3 = 튜플객체`
- 형변환: `tuple(객체)`

#### 튜플과 리스트

: 튜플은 생성한 후에는 수정할 수 없기 때문에 리스트에 있는 `append()`나 `insert()` 등 해당 데이터를 추가, 삭제, 수정할 수 있는 매서드를 사용할 수 없다.

##### 튜플의 장점

- 튜플은 더 적은 공간을 사용
- 튜플의 데이터가 손상될 수 없다 (데이터의 신뢰성)
- 튜플을 딕셔너리 키로 사용할 수 있다
- **네임드 튜플**은 객체의 단순한 대안이 될 수 있다
- 함수의 인자는 튜플로 전달된다

~~~python
# 튜플을 사용한 값의 교환
password = 'swordfish'
icecream = 'tuttifrutti'

password, icecream = icecream, password

print(password, icecream) # tuttifrutti swordfish
print(type(password), type(icecream)) # <class 'str'> <class 'str'>
~~~

<br>

## 3. 딕셔너리 (Dictionary) `{}`

리스트와 비슷하지만,

- 항목을 순서를 따지지 않는다
- 0 또는 1과 같은 오프셋으로 항목을 선택할 수 없다
- 값(value)에 상응하는 고유한 키(key)를 지정한다
- 변경 가능한 데이터타입 → 키와 값 요소를 추가, 삭제, 수정 가능

<br>

- 딕셔너리 생성: `{}`
- 형변환: `dict(객체)`: 두 값으로 이루어진 시퀀스를 딕셔너리로 변환
- `딕셔너리객체['존재하는 키'] = '바꿀 값'`: 항목 변경
- `딕셔너리객체['존재하지 않는 키'] = '추가할 값'`: 항목 추가
- `딕셔너리객체.update(딕셔너리객체에 추가할 다른 딕셔너리 객체)`: 딕셔너리 결합
- `del 딕셔너리객체['키']`: 항목 삭제
- `딕셔너리객체.clear()`: 모든 항목 삭제 (빈 딕셔너리객체 반환)
- `'키' in 딕셔너리객체`: 딕셔너리에 키가 존재하는지 확인 (Boolean값 반환)
- `딕셔너리객체['키']`: 항목 얻기
- `딕셔너리객체.get('찾을 키', '옵션값')`: 항목 얻기
- `딕셔너리객체.keys()`: 모든 키값 얻기
- `딕셔너리객체.values()`: 모든 값 얻기
- `딕셔너리객체.items()`: 모든 쌍의 키와 값 얻기 (각 키와 값은 튜플로 반환)
- `복사할 새로운 딕셔너리객체 = 기존의 딕셔너리객체.copy()`: 딕셔너리 복사

<br>

## 4. 셋 (Set) `{}`

- 값은 버리고 키만 남은 딕셔너리와 같다 (순서가 없다)
- 어떤 것이 존재하는지 여부만 판단하기 위해서는 셋을 사용
- 키에 어떤 정보를 첨부해서 그 결과를 얻고 싶으면 딕셔너리를 사용
- 중복된 값을 버린다
- 오름차순으로 정렬한다

<br>

- 형변환: `set()`
- `for문`과 `in`연산자를 사용하여 값을 얻을 수 있다
- 교집합: `&`, `a.intersection(b)`
- 합집합: `|`, `a.union(b)`
- 차집합: `-`, `a.difference(b)` (첫번째 셋에는 있지만 두번째 셋에는 없는 멤버)
- 대칭차집합: `^`, `a.symetric_difference(b)` (한쪽 셋에는 들어있지만 양쪽 모두에 들어있지 않은 멤버)
- 부분집합: `<=`, `a.issubset(b)` (Boolean값 반환)
- 진부분집합: `<` (Boolean값 반환)
- 슈퍼셋: `>=`, `a.issuperset(b)` (Boolean값 반환) (모든 셋은 자기 자신의 슈퍼셋이다)
- 프로퍼슈퍼셋: `>` (Boolean값 반환) (모든 셋은 자신의 프로퍼 슈퍼셋이 될 수 없다)

